import sys
import json
import time
import asyncio
from PyQt5.QtWidgets import QApplication, QMainWindow, QVBoxLayout, QTableWidget, QTableWidgetItem, QWidget, QLabel
from PyQt5.QtCore import Qt, QTimer
from scapy.all import sniff, IP

class TrafficMonitorApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Traffic Monitor - Load Balancer")
        self.setGeometry(100, 100, 1000, 700)

        # Main layout
        main_widget = QWidget(self)
        self.setCentralWidget(main_widget)
        layout = QVBoxLayout(main_widget)

        # Traffic table
        self.traffic_table = QTableWidget()
        self.traffic_table.setColumnCount(5)
        self.traffic_table.setHorizontalHeaderLabels(["IP Address", "Location", "Timestamp", "OS", "Browser"])
        self.traffic_table.setStyleSheet("background-color: #f5f5f5;")
        layout.addWidget(self.traffic_table)

        # Downtime table
        self.downtime_table = QTableWidget()
        self.downtime_table.setColumnCount(2)
        self.downtime_table.setHorizontalHeaderLabels(["Downtime (ms)", "Recovery Time (s)"])
        self.downtime_table.setStyleSheet("background-color: #f5f5f5;")
        layout.addWidget(self.downtime_table)

        self.recovery_times = []
        self.downtimes = []

        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.update_traffic_table)
        self.update_timer.start(5000)  # Refresh every 5 seconds

    def update_traffic_table(self):
        try:
            with open("http_traffic.json", "r") as f:
                data = json.load(f)

            self.traffic_table.setRowCount(len(data))
            for row, entry in enumerate(data):
                self.traffic_table.setItem(row, 0, QTableWidgetItem(entry["ip_src"]))
                self.traffic_table.setItem(row, 1, QTableWidgetItem(entry["src_location"]))
                self.traffic_table.setItem(row, 2, QTableWidgetItem(entry["timestamp"]))
                self.traffic_table.setItem(row, 3, QTableWidgetItem(entry["os"]))
                self.traffic_table.setItem(row, 4, QTableWidgetItem(entry["browser"]))
        except FileNotFoundError:
            pass

    def update_downtime_table(self, downtime, recovery_time):
        row = self.downtime_table.rowCount()
        self.downtime_table.insertRow(row)
        self.downtime_table.setItem(row, 0, QTableWidgetItem(str(downtime)))
        self.downtime_table.setItem(row, 1, QTableWidgetItem(f"{recovery_time:.2f}"))

# Global variables for downtime computation
target_ip = "103.18.73.90"
downtime_threshold = 1000  # 1 second in ms
is_down = False
downtime_start = None
app_instance = None

async def packet_handler(pkt):
    global is_down, downtime_start, app_instance

    current_time = time.time() * 1000  # Convert to milliseconds
    if IP in pkt and pkt[IP].src == target_ip:
        if downtime_start:
            downtime_duration = current_time - downtime_start
            if downtime_duration > downtime_threshold:
                recovery_time = current_time / 1000
                app_instance.update_downtime_table(downtime_duration, recovery_time)
            downtime_start = None

        is_down = False
    else:
        if not is_down:
            downtime_start = current_time
            is_down = True

async def sniff_packets():
    print(f"Listening for packets from {target_ip}...")
    sniff(filter=f"ip host {target_ip}", prn=packet_handler, store=False)

async def main():
    global app_instance
    sniff_task = asyncio.create_task(sniff_packets())
    await sniff_task

if __name__ == '__main__':
    app = QApplication(sys.argv)
    app_instance = TrafficMonitorApp()
    app_instance.show()

    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
    sys.exit(app.exec_())
